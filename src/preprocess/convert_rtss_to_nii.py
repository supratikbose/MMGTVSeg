import pydicom
import numpy as np
import glob
from skimage import draw
from pipeline import volume #from vmsseg import volume
from preprocess import data_util
import SimpleITK

def poly2mask(vertex_row_coords, vertex_col_coords, shape):
    #Generated by raster scan??
    fill_row_coords, fill_col_coords = draw.polygon(vertex_row_coords, vertex_col_coords, shape)
    mask = np.zeros(shape, dtype=np.bool)
    mask[fill_row_coords, fill_col_coords] = True
    return mask

def find_nearest(a, a0):
    idx = np.abs(a - a0).argmin()
    val = a.flat[idx] #flat is a 1-D iterator on the nd-array
    return val, idx

def convert_rtss_to_nii(rtss_fname, dicom_dir, output_img_fname, output_lbl_fname, structure):

    successful = True

    # load RTSS and verify it is proper RTSS object
    rtss = pydicom.read_file(rtss_fname) 
    if not (rtss.SOPClassUID == '1.2.840.10008.5.1.4.1.1.481.3'):
        print('Error: Not a DICOM RTSS file.')
        exit()

    structure_roi_num = 0
    if hasattr(rtss, 'RTROIObservationsSequence'):   
        for i in range(0, len(rtss.RTROIObservationsSequence)):
            if hasattr(rtss.RTROIObservationsSequence[i], 'ROIObservationLabel'):
                structure_name_rtss = rtss.RTROIObservationsSequence[i].ROIObservationLabel
                if ( structure_name_rtss.lower() == structure.lower() ):
                    structure_roi_num = rtss.RTROIObservationsSequence[i].ReferencedROINumber
                    break
            #else:
                #print('Warning: rtss.RTROIObservationsSequence[%d] does not have ROIObservationLabel' %(i))
    #else:
        #print('Does not have RTROIObservationsSequence')

    if hasattr(rtss, 'StructureSetROISequence'):   
        for i in range(0, len(rtss.StructureSetROISequence)):
            if hasattr(rtss.StructureSetROISequence[i], 'ROIName'):
                structure_name_rtss = rtss.StructureSetROISequence[i].ROIName
                if ( structure_name_rtss.lower() == structure.lower() ):
                    structure_roi_num = rtss.StructureSetROISequence[i].ROINumber
                    break
            #else:
                #print('Warning: rtss.StructureSetROISequence[%d] does not have ROIName' %(i))
    else:
        print('Does not have StructureSetROISequence')

    print('Structure ROI number: ', structure_roi_num)


    if hasattr(rtss, 'ROIContourSequence'):   

        # find corresponding contour sequence index
        contour_sequence_idx = None
        for i in range(0, len(rtss.ROIContourSequence)):
            if (rtss.ROIContourSequence[i].ReferencedROINumber == structure_roi_num):
                contour_sequence_idx = i

        if (contour_sequence_idx is not None):
            if hasattr(rtss.ROIContourSequence[contour_sequence_idx], 'ContourSequence'):

                # save DICOM CT as NIFTI
                data_util.convert_dicom_to_nii(dicom_dir, output_img_fname)

                img = SimpleITK.ReadImage(output_img_fname)
                spacing = img.GetSpacing()
                origin  = img.GetOrigin()
                vol_size = img.GetSize()
                direction = img.GetDirection()
                print('Image direction cosines: ', direction)
                #Z-posiion in patient co-ordinate of the slice con-taining the contor
                z_pos = origin[2] + np.arange(0, vol_size[2]*spacing[2], spacing[2])    

                # construct empty label volume based CT DICOM info
                num_slices = vol_size[2]
                lbl_vol = np.zeros(shape=vol_size, dtype=np.uint8)
            
                # get all points for one ROI
                num_contour_slices = len(rtss.ROIContourSequence[contour_sequence_idx].ContourSequence)
                roi_pts = []
                for i in range(0, num_contour_slices):
                    pts = rtss.ROIContourSequence[contour_sequence_idx].ContourSequence[i].ContourData
                    #pts contains [x1,y1,z1,x2,y2,z2,...,xN,yN,zN]
                    pts_array = np.ndarray((len(pts)//3, 3))
                    pts_array[:,0] = pts[0::3] #start with 1st element, till end, skip by 3
                    pts_array[:,1] = pts[1::3] #start with 2nd element, till end, skip by 3
                    pts_array[:,2] = pts[2::3] #start with 3rd element, till end, skip by 3
                    #sliceIdx computed with first slice having index 0
                    slice_idx = find_nearest(z_pos, pts_array[0,2])[1]

                    # TODO: double check that multiplying by direction cosine below works for all patient orientation (known to work for RAI and LPI)
                    #poly2mask(vertex_row_coords: vertex along row, vertex_col_coords: vertex along column, shape : 2D Mask shape)
                    mask = poly2mask( direction[0] * (pts_array[:,0] - origin[0]) / spacing[0], 
                        direction[4] * (pts_array[:,1] - origin[1]) / spacing[1], 
                        [vol_size[0], vol_size[1]])
                    #generated mask is being added since lbl_vol is initialized with zero and mas is binary
                    lbl_vol[:,:,slice_idx] += mask
                #Overlapping organs do not belong to any organ!!
                # set all cavities/overlaps to 0
                ti = lbl_vol > 1
                lbl_vol[ti] = 0

                # save DICOM RTSS as NIFTI
                volume.save_to_nii2(lbl_vol, output_lbl_fname, res=spacing, origin=origin)

            else:
                print('ERROR: File: %s, Failed to find ContourSequence in rtss.ROIContourSequence[%d]' %(rtss_fname, contour_sequence_idx))
                successful = False
        else:
            print('ERROR: File: %s, Failed to find contour_sequence_idx...' %(rtss_fname))
            successful = False
    else:
        print('ERROR: File: %s, RTSS file does not have rtss.ROIContourSequence ...' %(rtss_fname))
        successful = False
    
    return successful    

def convert_rtss_to_nii_and_resample(rtss_fname, dicom_dir, output_img_fname, output_lbl_fname, structure, cropped_vol_size, resolution, 
            padding, pad_value, clamp_range, center_label):

    successful = True

    # load RTSS and verify it is proper RTSS object
    rtss = pydicom.read_file(rtss_fname) 
    if not (rtss.SOPClassUID == '1.2.840.10008.5.1.4.1.1.481.3'):
        print('Error: Not a DICOM RTSS file.')
        return False

    structure_roi_num = 0
    if hasattr(rtss, 'RTROIObservationsSequence'):   
        for i in range(0, len(rtss.RTROIObservationsSequence)):
            if hasattr(rtss.RTROIObservationsSequence[i], 'ROIObservationLabel'):
                structure_name_rtss = rtss.RTROIObservationsSequence[i].ROIObservationLabel
                if ( structure_name_rtss.lower() == structure.lower() ):
                    structure_roi_num = rtss.RTROIObservationsSequence[i].ReferencedROINumber
                    break
            #else:
                #print('Warning: rtss.RTROIObservationsSequence[%d] does not have ROIObservationLabel' %(i))
    #else:
        #print('Does not have RTROIObservationsSequence')

    if hasattr(rtss, 'StructureSetROISequence'):   
        for i in range(0, len(rtss.StructureSetROISequence)):
            if hasattr(rtss.StructureSetROISequence[i], 'ROIName'):
                structure_name_rtss = rtss.StructureSetROISequence[i].ROIName
                if ( structure_name_rtss.lower() == structure.lower() ):
                    structure_roi_num = rtss.StructureSetROISequence[i].ROINumber
                    break
            #else:
                #print('Warning: rtss.StructureSetROISequence[%d] does not have ROIName' %(i))
    else:
        print('Does not have StructureSetROISequence')

    print('Structure ROI number: ', structure_roi_num)


    if hasattr(rtss, 'ROIContourSequence'):   

        # find corresponding contour sequence index
        contour_sequence_idx = None
        for i in range(0, len(rtss.ROIContourSequence)):
            if (rtss.ROIContourSequence[i].ReferencedROINumber == structure_roi_num):
                contour_sequence_idx = i

        if (contour_sequence_idx is not None):
            if hasattr(rtss.ROIContourSequence[contour_sequence_idx], 'ContourSequence'):

                print('Reading DICOM folder: ,', dicom_dir)
                reader = SimpleITK.ImageSeriesReader()
                dicom_names = reader.GetGDCMSeriesFileNames(dicom_dir)
                reader.SetFileNames(dicom_names)
                img_img = reader.Execute() 
                size = img_img.GetSize()
                print( "Reading DICOM folder finished. Scan dimensions:", size[0], size[1], size[2] ) 

                spacing = img_img.GetSpacing()
                origin  = img_img.GetOrigin()
                vol_size = img_img.GetSize()
                direction = img_img.GetDirection()
                print('Image direction cosines: ', direction)
                z_pos = origin[2] + np.arange(0, vol_size[2]*spacing[2], spacing[2])    

                # construct empty label volume based CT DICOM info
                lbl_vol = np.zeros(shape=vol_size, dtype=np.uint8)
            
                # get all points for one ROI
                num_contour_slices = len(rtss.ROIContourSequence[contour_sequence_idx].ContourSequence)
                for i in range(0, num_contour_slices):
                    pts = rtss.ROIContourSequence[contour_sequence_idx].ContourSequence[i].ContourData
                    pts_array = np.ndarray((len(pts)//3, 3))
                    pts_array[:,0] = pts[0::3]
                    pts_array[:,1] = pts[1::3]
                    pts_array[:,2] = pts[2::3]

                    slice_idx = find_nearest(z_pos, pts_array[0,2])[1]

                    # TODO: double check that multiplying by direction cosine below works for all patient orientation (known to work for RAI and LPI)
                    mask = poly2mask( direction[0] * (pts_array[:,0] - origin[0]) / spacing[0], 
                        direction[4] * (pts_array[:,1] - origin[1]) / spacing[1], 
                        [vol_size[0], vol_size[1]])

                    lbl_vol[:,:,slice_idx] += mask
                
                # set all cavities/overlaps to 0
                ti = lbl_vol > 1
                lbl_vol[ti] = 0

                # resample, crop, and save image and label volumes as NIFTI
                lbl_img = SimpleITK.GetImageFromArray(np.transpose(lbl_vol.astype(np.uint8)), isVector=False)
                lbl_img.SetDirection(img_img.GetDirection())
                lbl_img.SetOrigin(img_img.GetOrigin())
                lbl_img.SetSpacing(img_img.GetSpacing())          
                img_img, lbl_img = data_util.resample_and_crop_volumes_in_memory(img_img, lbl_img, cropped_vol_size = cropped_vol_size, resolution = resolution, padding = padding,
                    pad_value = pad_value, clamp_range = clamp_range, center_label = center_label)                               
                # ensure that mask is nonempty after resampling (this can happen when resampling a small contour from high resolution to low resolution)
                lbl_vol = SimpleITK.GetArrayFromImage(lbl_img)
                if (np.count_nonzero(lbl_vol) == 0):
                    print('ERROR: Empty label mask after resampling and cropping')
                    successful = False
                else:
                    SimpleITK.WriteImage(lbl_img, output_lbl_fname)
                    SimpleITK.WriteImage(img_img, output_img_fname)

            else:
                print('ERROR: File: %s, Failed to find ContourSequence in rtss.ROIContourSequence[%d]' %(rtss_fname, contour_sequence_idx))
                successful = False
        else:
            print('ERROR: File: %s, Failed to find contour_sequence_idx...' %(rtss_fname))
            successful = False
    else:
        print('ERROR: File: %s, RTSS file does not have rtss.ROIContourSequence ...' %(rtss_fname))
        successful = False
    
    return successful    
